<?php

namespace App\Jobs;

use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Queue\Queueable;
use Illuminate\Support\Facades\Storage;
use Illuminate\Support\Facades\Log;
use App\Models\ProcessedFile;
use setasign\Fpdi\Fpdi;
use Mpdf\Mpdf;
use PhpOffice\PhpWord\IOFactory;
use Exception;

class MergePdfJob implements ShouldQueue
{
    use Queueable;

    /**
     * ID del ProcessedFile da processare
     * @var int
     */
    protected int $processedFileId;

    /**
     * Create a new job instance.
     */
    public function __construct(int $processedFileId)
    {
        $this->processedFileId = $processedFileId;
    }

    /**
     * Execute the job.
     */
    public function handle(): void
    {
        // Recupera il ProcessedFile
        $processedFile = ProcessedFile::find($this->processedFileId);
        if (!$processedFile) {
            Log::warning('MergePdfJob: ProcessedFile non trovato', ['id' => $this->processedFileId]);
            return;
        }

        if (!$processedFile->word_path || !$processedFile->gcs_path) {
            Log::warning('MergePdfJob: Word o PDF originale mancante', ['id' => $this->processedFileId]);
            return;
        }

        $currentStep = 'started';

        try {
            $disk = Storage::disk('gcs');

            // 1) Scarica il file Word da GCS (in memoria)
            $currentStep = 'downloading_word';
            $wordContent = $disk->get($processedFile->word_path);

            // 2) Converti Word in PDF usando librerie locali
            $pdfFromWordContent = $this->convertWordToPdfViaLocalLibraries($wordContent, basename($processedFile->word_path));

            // 3) Scarica il PDF originale (in memoria)
            $currentStep = 'downloading_original_pdf';
            $originalPdfContent = $disk->get($processedFile->gcs_path);

            // 4) Unisci i PDF in memoria (PDF dal Word prima, poi originale)
            $currentStep = 'merging_pdfs';
            $mergedPdfContent = $this->mergePdfsInMemory([$pdfFromWordContent, $originalPdfContent]);

            // 5) Carica il PDF unito su GCS
            $currentStep = 'uploading_merged_pdf';
            $gcsMergedPath = 'merged_pdfs/merged_' . $this->processedFileId . '.pdf';
            $disk->put($gcsMergedPath, $mergedPdfContent);

            // 6) Aggiorna il modello
            $processedFile->merged_pdf_path = $gcsMergedPath;
            $processedFile->status = 'merged';
            $processedFile->save();

        } catch (Exception $e) {
            Log::error('MergePdfJob failed', ['exception' => $e, 'processed_file_id' => $this->processedFileId, 'step' => $currentStep]);
            try {
                $processedFile->status = 'merge_error';
                $processedFile->error_message = '[' . $currentStep . '] ' . substr($e->getMessage(), 0, 1000);
                $processedFile->save();
            } catch (Exception $inner) {
                Log::error('MergePdfJob failed to update ProcessedFile after exception', ['exception' => $inner]);
            }
            return;
        }
    }




    /**
     * Converte DOCX in PDF usando LibreOffice.
     */
    private function convertWordToPdfViaLocalLibraries(string $wordContent, string $fileName): string
    {
        $tempWordFile = null;
        $tempDir = sys_get_temp_dir();
        
        try {
            // 1) Salva il file Word temporaneamente
            $tempWordFile = $tempDir . '/' . uniqid('word_', true) . '.docx';
            file_put_contents($tempWordFile, $wordContent);
            
            // 2) Comando LibreOffice per conversione
            $command = sprintf(
                'libreoffice --headless --convert-to pdf --outdir %s %s 2>&1',
                escapeshellarg($tempDir),
                escapeshellarg($tempWordFile)
            );
            
            // 3) Esegui la conversione
            exec($command, $output, $returnCode);
            
            if ($returnCode !== 0) {
                throw new Exception('LibreOffice conversion failed: ' . implode("\n", $output));
            }
            
            // 4) LibreOffice crea il PDF con lo stesso nome del file di input
            $expectedPdfPath = str_replace('.docx', '.pdf', $tempWordFile);
            
            if (!file_exists($expectedPdfPath)) {
                throw new Exception('PDF file not generated by LibreOffice');
            }
            
            // 5) Leggi il contenuto del PDF
            $pdfContent = file_get_contents($expectedPdfPath);
            
            // 6) Pulizia file temporanei
            if (file_exists($tempWordFile)) {
                unlink($tempWordFile);
            }
            if (file_exists($expectedPdfPath)) {
                unlink($expectedPdfPath);
            }
            
            return $pdfContent;
            
        } catch (Exception $e) {
            // Pulizia in caso di errore
            if ($tempWordFile && file_exists($tempWordFile)) {
                unlink($tempWordFile);
            }
            
            $expectedPdfPath = isset($tempWordFile) ? str_replace('.docx', '.pdf', $tempWordFile) : null;
            if ($expectedPdfPath && file_exists($expectedPdfPath)) {
                unlink($expectedPdfPath);
            }
            
            throw new Exception("Errore conversione Word->PDF con LibreOffice: " . $e->getMessage());
        }
    }

    /**
     * Unisce piÃ¹ PDF in memoria usando FPDI.
     */
    private function mergePdfsInMemory(array $pdfContents): string
    {
        $pdf = new Fpdi();
        $tempFiles = []; // Per tracciare i file temporanei da eliminare

        try {
            foreach ($pdfContents as $pdfContent) {
                // Crea un file temporaneo su disco
                $tempPath = tempnam(sys_get_temp_dir(), 'pdf_merge_');
                file_put_contents($tempPath, $pdfContent);
                $tempFiles[] = $tempPath; // Traccia per pulizia

                $pageCount = $pdf->setSourceFile($tempPath);
                for ($pageNo = 1; $pageNo <= $pageCount; $pageNo++) {
                    $templateId = $pdf->importPage($pageNo);
                    $size = $pdf->getTemplateSize($templateId);
                    $pdf->AddPage($size['orientation'], [$size['width'], $size['height']]);
                    $pdf->useTemplate($templateId);
                }
            }

            // Output in memoria
            $result = $pdf->Output('', 'S');

            // Pulizia dei file temporanei
            foreach ($tempFiles as $tempFile) {
                if (file_exists($tempFile)) {
                    unlink($tempFile);
                }
            }

            return $result;

        } catch (Exception $e) {
            // Pulizia in caso di errore
            foreach ($tempFiles as $tempFile) {
                if (file_exists($tempFile)) {
                    unlink($tempFile);
                }
            }
            throw $e;
        }
    }
}
